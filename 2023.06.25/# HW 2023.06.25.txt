ПРОДВИНУТАЯ РАБОТА С ФУНКЦИЯМИ

  ==========  1  ==========  

Написать функцию с именем pick_resistors, которая подбирает ближайшие к переданному номиналы сопротивления из всех рядов сопротивлений.

В электротехнике и электронике существует понятие разброса значения сопротивления резистора от номинала. Результатом этого явилось существование рядов номиналов резисторов, изготавливаемых с различной точностью: от ±20% до ±0.5%
    Подробнее здесь: https://digteh.ru/PCB/R/Nominal/

Необходимо для некоторого (заранее рассчитанного) значения сопротивления подобрать ближайший номинал из каждого ряда сопротивлений. Под ближайшими подразумеваются тот или те номиналы, разница которых с переданным значением сопротивления минимальна.
    Ряды номиналов, среди которых необходимо осуществить подбор, заданы в словаре в приложенном к заданию файле # ref 1.py

Функция принимает обязательным позиционно-ключевым аргументом целое число — значение сопротивления в диапазоне от 100 до 999 включительно.

Функция возвращает словарь или None.

    Ключи словаря:
        'Е6', 'Е12', 'Е24', 'Е48', 'Е96'
    
    Значения словаря должны быть объектами tuple. 
    В каждом кортеже должен быть один или больше объектов int — подобранные номиналы сопротивлений.
    
В данной задаче необходимо использовать встроенные функции высшего порядка map() и filter(). Для этих функций в свою очередь понадобится написать подходящие анонимные функции.

Примечание: не забывайте про встроенные функции abs() и min()

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> pick_resistors(112)
    {'E6': (100,), 'E12': (120,), 'E24': (110,), 'E48': (110,), 'E96': (113,)}
    >>> 
    >>> pick_resistors(549)
    {'E6': (470,), 'E12': (560,), 'E24': (560,), 'E48': (536, 562), 'E96': (549,)}



  ==========  2  ==========  

Написать генераторную функцию с именем deck, которая создаёт упорядоченную колоду карт.

Функция не принимает аргументы.

Функция возвращает объект генератор.
    
    На каждой итерации или при явном вызове встроенного метода __next__() генератор должен возвращать кортеж из двух элементов:
        - целое число, обозначающее номинал карты: 2, 3 ... 10, 11 — валет, 12 — дама, 13 — король, 14 — туз
        - строка, обозначающая масть карты: 'черви', 'бубны', 'пики', 'трефы'

Колода упорядочивается следующим образом: сначала все номиналы червей, затем все номиналы бубен, затем все номиналы пик и в конце все номиналы треф.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> list(deck())[::13]
    [(2, 'черви'), (2, 'бубны'), (2, 'пики'), (2, 'трефы')]



  ==========  3  ==========  

Написать функцию высшего порядка с именем math_function_resolver, которая вычисляет округлённые значения для различных математических функций.

Функция принимает обязательным аргументом математическую функцию, произвольное количество значений x для математической функции и переключатель: тип вычисляемых значений float или str.
    
    Математическая функция должна быть строго позиционным аргументом, передаётся в виде вызываемого объекта.
        Данная функция должна принимать один обязательный позиционно-ключевой аргумент — число x, для которого необходимо вычислить значение математической функции. Это должно быть описано в документации к функции высшего порядка.
    
    Значения x для математической функции должны быть строго позиционными, передаются в виде произвольного кортежа объектов int или float.
    
    Переключатель должен быть строго ключевым, передаётся в виде объекта bool, значение по умолчанию False (тип вычисляемых значений float).

Функция возвращает объект списка с вычисленными значениями математической функции для переданных значений x.
    
    Элементами списка должны быть объекты float или объекты str в зависимости от значения аргумента переключателя.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> math_function_resolver(lambda x: 0.5*x + 2, *range(1, 10))
    [2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5]
    >>> 
    >>> math_function_resolver(lambda x: -0.5*x + 2, *range(1, 10))
    [1.5, 1.0, 0.5, 0.0, -0.5, -1.0, -1.5, -2.0, -2.5]
    >>> 
    >>> math_function_resolver(lambda x: 2.72**x, *range(1, 10), strings=True)
    ['2.72', '7.4', '20.12', '54.74', '148.88', '404.96', '1101.49', '2996.07', '8149.3']



  ==========  4  ==========  

Написать декоратор с именем repeat, который выполняет декорируемую функцию десять раз.

Это достаточно распространённая задача в сфере тестирования.

Декоратор может применяться к функциям с различным набором позиционных и ключевых аргументов.

Работу написанного декоратора необходимо проверить с помощью дополнительной произвольной функции.

Пример проверки:
    >>> def testing_function():
    ...     print('python')
    ...
    >>> testing_function = repeat(testing_function)
    >>> 
    >>> 
    >>> testing_function()
    python
    python
    python
    python
    python
    python
    python
    python
    python
    python



  ==========  5  ==========  

Написать декоратор с именем logger, который в стандартном потоке вывода ведёт журнал вызовов декорируемой функции.

В журнал необходимо внести имя вызванной функции и перечислить переданные аргументы. Ключевые аргументы должны быть перечислены с указанием ключа — имени параметра, в который эти аргументы передаются. 

Помимо переданных аргументов в журнал необходимо внести использованные значения по умолчанию.
    
    Значения по умолчанию доступны во встроенных атрибутах объекта функции __defaults__ (позиционные) и __kwdefaults__ (ключевые)
    
    Количество объявленных в функции строго позиционных и позиционно-ключевых параметров доступно в атрибуте функции __code__.co_argcount

В случае возникновения исключения его имя и текст также должны быть внесены в журнал, само исключение при перехвате игнорируется.
    
    Перехват любого исключения (в данном случае требуется перехватывать именно любое исключение, потому что декоратор может быть применён к произвольной функции) возможен при использовании базового класса Exception:
    try:
        int('a')
    except Exception:
        pass
    
    Доступ к объекту исключения возможен при использовании конструкции as <переменная>:
    try:
        sorted(150)
    except TypeError as exception:
        print(exception)
    
    Имя объекта исключения доступно во встроенном атрибуте __name__. Текст исключения (без обратной трассировки) возвращается при получении строкового представления объекта исключения. 
    В примере выше в stdout будет выведено: 'int' object is not iterable.

Декоратор может применяться к функциям с различным набором позиционных и ключевых аргументов.

Работу написанного декоратора необходимо проверить с помощью дополнительной произвольной функции.

Пример проверки:
    >>> def div_round(num1, num2, *, digits=0):
    ...     return round(num1 / num2, digits)
    ...
    >>> div_round = logger(div_round)
    >>> 
    >>> 
    >>> div_round(1, 3, digits=2)
    div_round(1, 3, digits=2) -> 0.33
    0.33
    >>> div_round(7, 2)
    div_round(7, 2, digits=0) -> 4.0
    4.0
    >>> div_round(5, 0)
    div_round(5, 0, digits=0) -> 
        ZeroDivisionError: division by zero
    >>> 



  =========================  

Каждая функция должна быть документирована, её параметры и возвращаемое значение должны быть аннотированы.

Работа функций проверяется в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки результатов проверки копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.